# Day16

---

## 문제풀이 열여섯번째날 <2023-1-18>

> **********풀이 문제**********
>
- 한 번만 등장한 문자
    - 2일에 걸쳐서 풀이한 문제… replace를 사용하면 해당문자 전체가 수정되서 헤맸다. 그래서 방법을 바꾸어서 자기 자신을 제외한 동일한 문자가 카운트되지 않을 때 그 문자를 반환시킬 변수에 저장해서 리턴하는 방법이다.
- 숨어있는 숫자의 덧셈(2)
    - 문자열안에서 숫자를 확인해야하는데 그 방법을 모르겠어서 찾아보았다. Char to Int로 변환해서 문자 ‘0’~’9’의 아스키 코드 48~ 57안에 포함되는지를 검사할 수 있다. 그런데 연속된 수를 만드는 중에 풀이가 막혀버렸다…

    ```java
    public int solution(String my_string) {
            int answer = 0;
            int cnt = 1;
            int num = 0;
            char[] str_arr = my_string.toCharArray();
            
            for(int i=0; i<str_arr.length; i++){
                if(str_arr[i] >= 48 && str_arr[i] <= 57){
                    
                    while(str_arr[i+cnt] >= 48 && str_arr[i+cnt] <= 57){
                        num += str_arr[i] * 10;
                        cnt++;
                    }
                    if(cnt == 1)
                        answer += str_arr[i];
                    else{
                        for(int j=str_arr[i+1]; j<cnt; j *= 10){
                            str_arr[i+j] * 10;
    												//막혔다...
                        } 
                    }
                }
            }
            return answer;
        }
    ```

    - 공백으로 알파벳을 구분해서 배열에 저장하고, 공백을 기준으로 연속된 숫자가 자동으로 더해진다. (다른사람 풀이 참조)
- 7의 개수
    - 행운의 숫자 7을 좋아하는 머쓱이 새끼 때문에 탄생한 문제이다. while문에서 0이 아닐 때를 조건문으로 써야하는데 0일 때를 써서 에러가 발생했다.. 그것 외에는 의외로 간단한 문제였다. !!
- 공던지기
    - 내가 굉장히 복잡스럽게 했구나… 그렇지만 다른사람들 처럼 한줄로 끝내는 법은 쉽게 생각해내지 못했을거다…
- 영어가 싫어요
    - zero-nine까지 배열을 만들고 switch문에서 주어진 문자를 포함하면 0-9의 문자를 더해서 Long타입으로 변환하려 했지만 어째서인지 0이 자꾸 없어진채로 나왔다.
    - 주어진 문자열 자체에 replace() 메소드를 사용해서 0-9까지의 문자로 변환해서 Long 타입으로 했더니 통과되었다.